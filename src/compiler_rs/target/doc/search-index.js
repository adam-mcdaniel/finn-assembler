var N = null;var searchIndex = {};
searchIndex["bigdecimal"]={"doc":"A Big Decimal","items":[[8,"FromPrimitive","bigdecimal","A generic trait for converting a number to a value.",N,N],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the value cannot be represented by this value, then `None` is returned.",0,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",0,[[["f64"]],["option"]]],[8,"Num","","The base trait for numeric types, covering `0` and `1` values, comparisons, basic numeric operations, and string conversion.",N,N],[16,"FromStrRadixErr","","",1,N],[10,"from_str_radix","","Convert from a string and radix <= 36.",1,[[["str"],["u32"]],["result"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",N,N],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",2,[[],["self"]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative identity.",2,[[["self"]],["bool"]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative).",N,N],[10,"abs","","Computes the absolute value.",3,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",3,[[["self"],["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",3,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",3,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",3,[[["self"]],["bool"]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",N,N],[11,"to_isize","","Converts the value of `self` to an `isize`.",4,[[["self"]],["option",["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`.",4,[[["self"]],["option",["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`.",4,[[["self"]],["option",["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`.",4,[[["self"]],["option",["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`.",4,[[["self"]],["option",["i64"]]]],[11,"to_i128","","Converts the value of `self` to an `i128`.",4,[[["self"]],["option",["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`.",4,[[["self"]],["option",["usize"]]]],[11,"to_u8","","Converts the value of `self` to an `u8`.",4,[[["self"]],["option",["u8"]]]],[11,"to_u16","","Converts the value of `self` to an `u16`.",4,[[["self"]],["option",["u16"]]]],[11,"to_u32","","Converts the value of `self` to an `u32`.",4,[[["self"]],["option",["u32"]]]],[10,"to_u64","","Converts the value of `self` to an `u64`.",4,[[["self"]],["option",["u64"]]]],[11,"to_u128","","Converts the value of `self` to an `u128`.",4,[[["self"]],["option",["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`.",4,[[["self"]],["option",["f32"]]]],[11,"to_f64","","Converts the value of `self` to an `f64`.",4,[[["self"]],["option",["f64"]]]],[8,"Zero","","Defines an additive identity element for `Self`.",N,N],[10,"zero","","Returns the additive identity element of `Self`, `0`.",5,[[],["self"]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",5,[[["self"]],["bool"]]],[3,"BigDecimal","","A big decimal type.",N,N],[4,"ParseBigDecimalError","","",N,N],[13,"ParseDecimal","","",6,N],[13,"ParseInt","","",6,N],[13,"ParseBigInt","","",6,N],[13,"Empty","","",6,N],[13,"Other","","",6,N],[11,"new","","Creates and initializes a `BigDecimal`.",7,[[["bigint"],["i64"]],["bigdecimal"]]],[11,"parse_bytes","","Creates and initializes a `BigDecimal`.",7,N],[11,"with_scale","","Return a new BigDecimal object equivalent to self, with internal scaling set to the number specified. If the new_scale is lower than the current value (indicating a larger power of 10), digits will be dropped (as precision is lower)",7,[[["self"],["i64"]],["bigdecimal"]]],[11,"with_prec","","Return a new BigDecimal object with precision set to new value",7,[[["self"],["u64"]],["bigdecimal"]]],[11,"sign","","Return the sign of the `BigDecimal` as `num::bigint::Sign`.",7,[[["self"]],["sign"]]],[11,"as_bigint_and_exponent","","Return the internal big integer value and an exponent. Note that a positive exponent indicates a negative power of 10.",7,N],[11,"into_bigint_and_exponent","","Convert into the internal big integer value and an exponent. Note that a positive exponent indicates a negative power of 10.",7,N],[11,"digits","","Number of digits in the non-scaled integer representation",7,[[["self"]],["u64"]]],[11,"abs","","Compute the absolute value of number",7,[[["self"]],["bigdecimal"]]],[11,"double","","",7,[[["self"]],["bigdecimal"]]],[11,"half","","Divide this efficiently by 2",7,[[["self"]],["bigdecimal"]]],[11,"square","","",7,[[["self"]],["bigdecimal"]]],[11,"cube","","",7,[[["self"]],["bigdecimal"]]],[11,"sqrt","","Take the square root of the number",7,[[["self"]],["option",["bigdecimal"]]]],[11,"cbrt","","Take the cube root of the number",7,[[["self"]],["bigdecimal"]]],[11,"inverse","","Compute the reciprical of the number: x-1",7,[[["self"]],["bigdecimal"]]],[11,"exp","","Evaluate the natural-exponential function ex",7,[[["self"]],["bigdecimal"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"to_string","","",7,[[["self"]],["string"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"to_string","","",6,[[["self"]],["string"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"from","","",6,[[["parsefloaterror"]],["parsebigdecimalerror"]]],[11,"from","","",6,[[["parseinterror"]],["parsebigdecimalerror"]]],[11,"from","","",6,[[["parsebiginterror"]],["parsebigdecimalerror"]]],[11,"from","","",7,[[["i64"]],["self"]]],[11,"from","","",7,[[["u64"]],["self"]]],[11,"from","","",7,N],[11,"from","","",7,[[["bigint"]],["self"]]],[11,"from","","",7,[[["u8"]],["self"]]],[11,"from","","",7,[[["u16"]],["self"]]],[11,"from","","",7,[[["u32"]],["self"]]],[11,"from","","",7,[[["i8"]],["self"]]],[11,"from","","",7,[[["i16"]],["self"]]],[11,"from","","",7,[[["i32"]],["self"]]],[11,"from","","",7,[[["f32"]],["self"]]],[11,"from","","",7,[[["f64"]],["self"]]],[11,"cmp","","Complete ordering implementation for BigDecimal",7,[[["self"],["bigdecimal"]],["ordering"]]],[11,"clone","","",7,[[["self"]],["bigdecimal"]]],[11,"partial_cmp","","",7,[[["self"],["bigdecimal"]],["option",["ordering"]]]],[11,"default","","",7,[[],["bigdecimal"]]],[11,"eq","","",6,[[["self"],["parsebigdecimalerror"]],["bool"]]],[11,"ne","","",6,[[["self"],["parsebigdecimalerror"]],["bool"]]],[11,"eq","","",7,[[["self"],["bigdecimal"]],["bool"]]],[11,"from_str","","",7,[[["str"]],["result",["bigdecimal","parsebigdecimalerror"]]]],[11,"add","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"add","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"add","","",7,[[["self"],["bigint"]],["bigdecimal"]]],[11,"add","","",7,[[["self"],["bigint"]],["bigdecimal"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"hash","","",7,[[["self"],["h"]]]],[11,"sub","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"sub","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"sub","","",7,[[["self"],["bigint"]],["bigdecimal"]]],[11,"sub","","",7,[[["self"],["bigint"]],["bigdecimal"]]],[11,"mul","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"mul","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"mul","","",7,[[["self"],["bigint"]],["bigdecimal"]]],[11,"mul","","",7,[[["self"],["bigint"]],["bigdecimal"]]],[11,"div","","",7,N],[11,"div","","",7,N],[11,"div","","",7,N],[11,"div","","",7,N],[11,"div","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"div","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"rem","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"rem","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"neg","","",7,[[["self"]],["bigdecimal"]]],[11,"add_assign","","",7,[[["self"],["bigdecimal"]]]],[11,"add_assign","","",7,[[["self"],["bigdecimal"]]]],[11,"add_assign","","",7,[[["self"],["bigint"]]]],[11,"add_assign","","",7,[[["self"],["bigint"]]]],[11,"sub_assign","","",7,[[["self"],["bigdecimal"]]]],[11,"sub_assign","","",7,[[["self"],["bigdecimal"]]]],[11,"sub_assign","","",7,[[["self"],["bigint"]]]],[11,"sub_assign","","",7,[[["self"],["bigint"]]]],[11,"mul_assign","","",7,[[["self"],["bigdecimal"]]]],[11,"mul_assign","","",7,[[["self"],["bigdecimal"]]]],[11,"sum","","",7,[[["i"]],["bigdecimal"]]],[11,"sum","","",7,[[["i"]],["bigdecimal"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"description","","",6,[[["self"]],["str"]]],[11,"to_bigint","","",7,[[["self"]],["option",["bigint"]]]],[11,"zero","","",7,[[],["bigdecimal"]]],[11,"is_zero","","",7,[[["self"]],["bool"]]],[11,"from_i64","","",7,[[["i64"]],["option"]]],[11,"from_u64","","",7,[[["u64"]],["option"]]],[11,"from_f32","","",7,[[["f32"]],["option"]]],[11,"from_f64","","",7,[[["f64"]],["option"]]],[11,"abs","","",7,[[["self"]],["bigdecimal"]]],[11,"abs_sub","","",7,[[["self"],["bigdecimal"]],["bigdecimal"]]],[11,"signum","","",7,[[["self"]],["bigdecimal"]]],[11,"is_positive","","",7,[[["self"]],["bool"]]],[11,"is_negative","","",7,[[["self"]],["bool"]]],[11,"to_i64","","",7,[[["self"]],["option",["i64"]]]],[11,"to_u64","","",7,[[["self"]],["option",["u64"]]]],[11,"to_f64","","",7,[[["self"]],["option",["f64"]]]],[11,"from_str_radix","","Creates and initializes a BigDecimal.",7,[[["str"],["u32"]],["result",["bigdecimal","parsebigdecimalerror"]]]],[11,"one","","",7,[[],["bigdecimal"]]]],"paths":[[8,"FromPrimitive"],[8,"Num"],[8,"One"],[8,"Signed"],[8,"ToPrimitive"],[8,"Zero"],[4,"ParseBigDecimalError"],[3,"BigDecimal"]]};
searchIndex["cable_lang"]={"doc":"","items":[[0,"runtime","cable_lang","",N,N],[3,"Pair","cable_lang::runtime","",N,N],[3,"Scope","","",N,N],[3,"StackFrame","","",N,N],[11,"new","","",0,[[["option",["box"]]],["self"]]],[11,"new","","",1,[[["option",["box"]],["scope"],["value"]],["self"]]],[11,"from_instructions","","",1,[[["value"]],["self"]]],[11,"run","","",1,[[["self"]]]],[0,"table","cable_lang","",N,N],[3,"Table","cable_lang::table","",N,N],[11,"new","","",2,[[],["self"]]],[11,"set","","",2,[[["self"],["string"],["t"]]]],[11,"get","","",2,[[["self"],["string"]],["option"]]],[11,"keys","","",2,[[["self"]],["vec",["string"]]]],[11,"values","","",2,[[["self"]],["vec"]]],[0,"object","cable_lang","",N,N],[4,"Instruction","cable_lang::object","",N,N],[13,"Print","","",3,N],[13,"Println","","",3,N],[13,"Add","","",3,N],[13,"Mul","","",3,N],[13,"Sub","","",3,N],[13,"Div","","",3,N],[13,"Mod","","",3,N],[13,"Call","","",3,N],[13,"Load","","",3,N],[13,"Store","","",3,N],[13,"GetAttr","","",3,N],[13,"SetAttr","","",3,N],[13,"Execute","","",3,N],[13,"Pass","","",3,N],[4,"Problem","","",N,N],[13,"IncompatibleTypes","","",4,N],[13,"ValueError","","",4,N],[4,"Type","","",N,N],[13,"Str","","",5,N],[13,"Num","","",5,N],[13,"List","","",5,N],[13,"Function","","",5,N],[13,"Instance","","",5,N],[13,"Problem","","",5,N],[13,"Nothing","","",5,N],[13,"Command","","",5,N],[6,"Contents","","",N,N],[17,"NOTHING","","",N,N],[8,"Object","","",N,N],[10,"new","","",6,[[["type"],["contents"]],["self"]]],[11,"from_string","","",6,[[["string"]],["self"]]],[11,"from_str","","",6,[[["str"]],["self"]]],[11,"from_f64","","",6,[[["f64"]],["self"]]],[11,"from_number","","",6,[[["bigdecimal"]],["self"]]],[11,"from_instruction","","",6,[[["instruction"]],["self"]]],[11,"from_problem","","",6,[[["problem"]],["self"]]],[11,"from_vector","","",6,[[["vec"]],["self"]]],[11,"from_nothing","","",6,[[],["self"]]],[11,"from_foreign_function","","",6,N],[10,"get_type","","",6,[[["self"]],["type"]]],[10,"get_list","","",6,[[["self"]],["vec"]]],[10,"get_contents","","",6,[[["self"]],["contents"]]],[10,"get_attributes","","",6,[[["self"]],["table"]]],[10,"get_foreign_function","","",6,N],[10,"set_type","","",6,[[["self"],["type"]]]],[10,"set_list","","",6,[[["self"],["vec"]]]],[10,"set_contents","","",6,[[["self"],["contents"]]]],[10,"set_attributes","","",6,[[["self"],["table"]]]],[10,"set_foreign_function","","",6,N],[11,"get_attr","","",6,[[["self"],["string"]],["self"]]],[11,"as_number","","",6,[[["self"]],["bigdecimal"]]],[11,"as_string","","",6,[[["self"]],["string"]]],[11,"as_list","","",6,[[["self"]],["vec"]]],[11,"as_instruction","","",6,[[["self"]],["instruction"]]],[11,"as_instance","","",6,[[["self"]],["table"]]],[11,"as_foreign_function","","",6,N],[11,"set_attr","","",6,[[["self"],["string"],["self"]]]],[11,"list_push","","",6,[[["self"],["self"]]]],[11,"list_pop","","",6,[[["self"]],["self"]]],[11,"call_foreign_function","","",6,[[["self"],["self"]],["self"]]],[11,"format","","",6,[[["self"]],["string"]]],[11,"print","","",6,[[["self"]]]],[11,"println","","",6,[[["self"]]]],[0,"value","cable_lang","",N,N],[3,"Value","cable_lang::value","",N,N],[0,"error","cable_lang","",N,N],[11,"from","cable_lang::runtime","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"from","cable_lang::table","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","cable_lang::object","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"from","cable_lang::value","",8,[[["t"]],["t"]]],[11,"to_string","","",8,[[["self"]],["string"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"new","","",8,[[["type"],["contents"]],["self"]]],[11,"get_type","","",8,[[["self"]],["type"]]],[11,"get_list","","",8,[[["self"]],["vec"]]],[11,"get_contents","","",8,[[["self"]],["contents"]]],[11,"get_attributes","","",8,[[["self"]],["table"]]],[11,"get_foreign_function","","",8,N],[11,"set_type","","",8,[[["self"],["type"]]]],[11,"set_list","","",8,[[["self"],["vec"]]]],[11,"set_contents","","",8,[[["self"],["contents"]]]],[11,"set_attributes","","",8,[[["self"],["table"]]]],[11,"set_foreign_function","","",8,N],[11,"clone","cable_lang::runtime","",7,[[["self"]],["pair"]]],[11,"clone","","",0,[[["self"]],["scope"]]],[11,"clone","","",1,[[["self"]],["stackframe"]]],[11,"clone","cable_lang::table","",2,[[["self"]],["table"]]],[11,"clone","cable_lang::object","",3,[[["self"]],["instruction"]]],[11,"clone","","",4,[[["self"]],["problem"]]],[11,"clone","","",5,[[["self"]],["type"]]],[11,"clone","cable_lang::value","",8,[[["self"]],["value"]]],[11,"eq","cable_lang::table","",2,[[["self"],["table"]],["bool"]]],[11,"ne","","",2,[[["self"],["table"]],["bool"]]],[11,"eq","cable_lang::object","",3,[[["self"],["instruction"]],["bool"]]],[11,"eq","","",4,[[["self"],["problem"]],["bool"]]],[11,"eq","","",5,[[["self"],["type"]],["bool"]]],[11,"ne","","",5,[[["self"],["type"]],["bool"]]],[11,"eq","cable_lang::value","",8,[[["self"],["value"]],["bool"]]],[11,"ne","","",8,[[["self"],["value"]],["bool"]]],[11,"add","","",8,N],[11,"fmt","","",8,[[["self"],["formatter"]],["result",["error"]]]],[11,"sub","","",8,N],[11,"mul","","",8,N],[11,"div","","",8,N],[11,"rem","","",8,N],[11,"fmt","cable_lang::runtime","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","cable_lang::table","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","cable_lang::object","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","cable_lang::value","",8,[[["self"],["formatter"]],["result"]]]],"paths":[[3,"Scope"],[3,"StackFrame"],[3,"Table"],[4,"Instruction"],[4,"Problem"],[4,"Type"],[8,"Object"],[3,"Pair"],[3,"Value"]]};
searchIndex["num_bigint"]={"doc":"A Big integer (signed version: `BigInt`, unsigned version: `BigUint`).","items":[[3,"ParseBigIntError","num_bigint","",N,N],[3,"BigUint","","A big unsigned integer type.",N,N],[3,"BigInt","","A big signed integer type.",N,N],[4,"Sign","","A Sign is a `BigInt`'s composing element.",N,N],[13,"Minus","","",0,N],[13,"NoSign","","",0,N],[13,"Plus","","",0,N],[11,"new","","Creates and initializes a BigInt.",1,[[["sign"],["vec",["u32"]]],["bigint"]]],[11,"from_biguint","","Creates and initializes a `BigInt`.",1,[[["sign"],["biguint"]],["bigint"]]],[11,"from_slice","","Creates and initializes a `BigInt`.",1,N],[11,"assign_from_slice","","Reinitializes a `BigInt`.",1,N],[11,"from_bytes_be","","Creates and initializes a `BigInt`.",1,N],[11,"from_bytes_le","","Creates and initializes a `BigInt`.",1,N],[11,"from_signed_bytes_be","","Creates and initializes a `BigInt` from an array of bytes in two's complement binary representation.",1,N],[11,"from_signed_bytes_le","","Creates and initializes a `BigInt` from an array of bytes in two's complement.",1,N],[11,"parse_bytes","","Creates and initializes a `BigInt`.",1,N],[11,"from_radix_be","","Creates and initializes a `BigInt`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",1,N],[11,"from_radix_le","","Creates and initializes a `BigInt`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",1,N],[11,"to_bytes_be","","Returns the sign and the byte representation of the `BigInt` in big-endian byte order.",1,N],[11,"to_bytes_le","","Returns the sign and the byte representation of the `BigInt` in little-endian byte order.",1,N],[11,"to_signed_bytes_be","","Returns the two's complement byte representation of the `BigInt` in big-endian byte order.",1,[[["self"]],["vec",["u8"]]]],[11,"to_signed_bytes_le","","Returns the two's complement byte representation of the `BigInt` in little-endian byte order.",1,[[["self"]],["vec",["u8"]]]],[11,"to_str_radix","","Returns the integer formatted as a string in the given radix. `radix` must be in the range `2...36`.",1,[[["self"],["u32"]],["string"]]],[11,"to_radix_be","","Returns the integer in the requested base in big-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",1,N],[11,"to_radix_le","","Returns the integer in the requested base in little-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",1,N],[11,"sign","","Returns the sign of the `BigInt` as a `Sign`.",1,[[["self"]],["sign"]]],[11,"bits","","Determines the fewest bits necessary to express the `BigInt`, not including the sign.",1,[[["self"]],["usize"]]],[11,"to_biguint","","Converts this `BigInt` into a `BigUint`, if it's not negative.",1,[[["self"]],["option",["biguint"]]]],[11,"checked_add","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_sub","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_mul","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_div","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"modpow","","Returns `(self ^ exponent) mod modulus`",1,[[["self"],["self"],["self"]],["self"]]],[11,"sqrt","","Returns the truncated principal square root of `self` -- see Roots::sqrt.",1,[[["self"]],["self"]]],[11,"cbrt","","Returns the truncated principal cube root of `self` -- see Roots::cbrt.",1,[[["self"]],["self"]]],[11,"nth_root","","Returns the truncated principal `n`th root of `self` -- See Roots::nth_root.",1,[[["self"],["u32"]],["self"]]],[11,"new","","Creates and initializes a `BigUint`.",2,[[["vec",["u32"]]],["biguint"]]],[11,"from_slice","","Creates and initializes a `BigUint`.",2,N],[11,"assign_from_slice","","Assign a value to a `BigUint`.",2,N],[11,"from_bytes_be","","Creates and initializes a `BigUint`.",2,N],[11,"from_bytes_le","","Creates and initializes a `BigUint`.",2,N],[11,"parse_bytes","","Creates and initializes a `BigUint`. The input slice must contain ascii/utf8 characters in [0-9a-zA-Z]. `radix` must be in the range `2...36`.",2,N],[11,"from_radix_be","","Creates and initializes a `BigUint`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",2,N],[11,"from_radix_le","","Creates and initializes a `BigUint`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",2,N],[11,"to_bytes_be","","Returns the byte representation of the `BigUint` in big-endian byte order.",2,[[["self"]],["vec",["u8"]]]],[11,"to_bytes_le","","Returns the byte representation of the `BigUint` in little-endian byte order.",2,[[["self"]],["vec",["u8"]]]],[11,"to_str_radix","","Returns the integer formatted as a string in the given radix. `radix` must be in the range `2...36`.",2,[[["self"],["u32"]],["string"]]],[11,"to_radix_be","","Returns the integer in the requested base in big-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",2,[[["self"],["u32"]],["vec",["u8"]]]],[11,"to_radix_le","","Returns the integer in the requested base in little-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",2,[[["self"],["u32"]],["vec",["u8"]]]],[11,"bits","","Determines the fewest bits necessary to express the `BigUint`.",2,[[["self"]],["usize"]]],[11,"modpow","","Returns `(self ^ exponent) % modulus`.",2,[[["self"],["self"],["self"]],["self"]]],[11,"sqrt","","Returns the truncated principal square root of `self` -- see Roots::sqrt",2,[[["self"]],["self"]]],[11,"cbrt","","Returns the truncated principal cube root of `self` -- see Roots::cbrt.",2,[[["self"]],["self"]]],[11,"nth_root","","Returns the truncated principal `n`th root of `self` -- see Roots::nth_root.",2,[[["self"],["u32"]],["self"]]],[8,"ToBigUint","","A generic trait for converting a value to a `BigUint`.",N,N],[10,"to_biguint","","Converts the value of `self` to a `BigUint`.",3,[[["self"]],["option",["biguint"]]]],[8,"ToBigInt","","A generic trait for converting a value to a `BigInt`.",N,N],[10,"to_bigint","","Converts the value of `self` to a `BigInt`.",4,[[["self"]],["option",["bigint"]]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"to_bigint","","",1,[[["self"]],["option",["bigint"]]]],[11,"to_bigint","","",2,[[["self"]],["option",["bigint"]]]],[11,"to_biguint","","",1,[[["self"]],["option",["biguint"]]]],[11,"to_biguint","","",2,[[["self"]],["option",["biguint"]]]],[11,"from","","",1,[[["i64"]],["self"]]],[11,"from","","",1,[[["i128"]],["self"]]],[11,"from","","",1,[[["i8"]],["self"]]],[11,"from","","",1,[[["i16"]],["self"]]],[11,"from","","",1,[[["i32"]],["self"]]],[11,"from","","",1,[[["isize"]],["self"]]],[11,"from","","",1,[[["u64"]],["self"]]],[11,"from","","",1,[[["u128"]],["self"]]],[11,"from","","",1,[[["u8"]],["self"]]],[11,"from","","",1,[[["u16"]],["self"]]],[11,"from","","",1,[[["u32"]],["self"]]],[11,"from","","",1,[[["usize"]],["self"]]],[11,"from","","",1,[[["biguint"]],["self"]]],[11,"from","","",2,[[["u64"]],["self"]]],[11,"from","","",2,[[["u128"]],["self"]]],[11,"from","","",2,[[["u8"]],["self"]]],[11,"from","","",2,[[["u16"]],["self"]]],[11,"from","","",2,[[["u32"]],["self"]]],[11,"from","","",2,[[["usize"]],["self"]]],[11,"cmp","","",0,[[["self"],["sign"]],["ordering"]]],[11,"cmp","","",1,[[["self"],["bigint"]],["ordering"]]],[11,"cmp","","",2,[[["self"],["biguint"]],["ordering"]]],[11,"clone","","",0,[[["self"]],["sign"]]],[11,"clone","","",1,[[["self"]],["bigint"]]],[11,"clone","","",2,[[["self"]],["biguint"]]],[11,"clone","","",5,[[["self"]],["parsebiginterror"]]],[11,"partial_cmp","","",0,[[["self"],["sign"]],["option",["ordering"]]]],[11,"partial_cmp","","",1,[[["self"],["bigint"]],["option",["ordering"]]]],[11,"partial_cmp","","",2,[[["self"],["biguint"]],["option",["ordering"]]]],[11,"default","","",1,[[],["bigint"]]],[11,"default","","",2,[[],["biguint"]]],[11,"eq","","",0,[[["self"],["sign"]],["bool"]]],[11,"eq","","",1,[[["self"],["bigint"]],["bool"]]],[11,"eq","","",2,[[["self"],["biguint"]],["bool"]]],[11,"eq","","",5,[[["self"],["parsebiginterror"]],["bool"]]],[11,"ne","","",5,[[["self"],["parsebiginterror"]],["bool"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"from_str","","",1,[[["str"]],["result",["bigint","parsebiginterror"]]]],[11,"from_str","","",2,[[["str"]],["result",["biguint","parsebiginterror"]]]],[11,"add","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"add","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"add","","",1,[[["self"],["u8"]],["bigint"]]],[11,"add","","",1,[[["self"],["u8"]],["bigint"]]],[11,"add","","",1,[[["self"],["u16"]],["bigint"]]],[11,"add","","",1,[[["self"],["u16"]],["bigint"]]],[11,"add","","",1,[[["self"],["usize"]],["bigint"]]],[11,"add","","",1,[[["self"],["usize"]],["bigint"]]],[11,"add","","",1,[[["self"],["i8"]],["bigint"]]],[11,"add","","",1,[[["self"],["i8"]],["bigint"]]],[11,"add","","",1,[[["self"],["i16"]],["bigint"]]],[11,"add","","",1,[[["self"],["i16"]],["bigint"]]],[11,"add","","",1,[[["self"],["isize"]],["bigint"]]],[11,"add","","",1,[[["self"],["isize"]],["bigint"]]],[11,"add","","",1,[[["self"],["u32"]],["bigint"]]],[11,"add","","",1,[[["self"],["u64"]],["bigint"]]],[11,"add","","",1,[[["self"],["u128"]],["bigint"]]],[11,"add","","",1,[[["self"],["u32"]],["bigint"]]],[11,"add","","",1,[[["self"],["u64"]],["bigint"]]],[11,"add","","",1,[[["self"],["u128"]],["bigint"]]],[11,"add","","",1,[[["self"],["i32"]],["bigint"]]],[11,"add","","",1,[[["self"],["i64"]],["bigint"]]],[11,"add","","",1,[[["self"],["i128"]],["bigint"]]],[11,"add","","",1,[[["self"],["i32"]],["bigint"]]],[11,"add","","",1,[[["self"],["i64"]],["bigint"]]],[11,"add","","",1,[[["self"],["i128"]],["bigint"]]],[11,"add","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"add","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"add","","",2,[[["self"],["u8"]],["biguint"]]],[11,"add","","",2,[[["self"],["u8"]],["biguint"]]],[11,"add","","",2,[[["self"],["u16"]],["biguint"]]],[11,"add","","",2,[[["self"],["u16"]],["biguint"]]],[11,"add","","",2,[[["self"],["usize"]],["biguint"]]],[11,"add","","",2,[[["self"],["usize"]],["biguint"]]],[11,"add","","",2,[[["self"],["u32"]],["biguint"]]],[11,"add","","",2,[[["self"],["u64"]],["biguint"]]],[11,"add","","",2,[[["self"],["u128"]],["biguint"]]],[11,"add","","",2,[[["self"],["u32"]],["biguint"]]],[11,"add","","",2,[[["self"],["u64"]],["biguint"]]],[11,"add","","",2,[[["self"],["u128"]],["biguint"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"hash","","",0,N],[11,"hash","","",1,N],[11,"hash","","",2,N],[11,"sub","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"sub","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u8"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u8"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u16"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u16"]],["bigint"]]],[11,"sub","","",1,[[["self"],["usize"]],["bigint"]]],[11,"sub","","",1,[[["self"],["usize"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i8"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i8"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i16"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i16"]],["bigint"]]],[11,"sub","","",1,[[["self"],["isize"]],["bigint"]]],[11,"sub","","",1,[[["self"],["isize"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u32"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u64"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u128"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u32"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u64"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u128"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i32"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i64"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i128"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i32"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i64"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i128"]],["bigint"]]],[11,"sub","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"sub","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u8"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u8"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u16"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u16"]],["biguint"]]],[11,"sub","","",2,[[["self"],["usize"]],["biguint"]]],[11,"sub","","",2,[[["self"],["usize"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u32"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u64"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u128"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u32"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u64"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u128"]],["biguint"]]],[11,"mul","","",0,[[["self"],["sign"]],["sign"]]],[11,"mul","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"mul","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u8"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u8"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u16"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u16"]],["bigint"]]],[11,"mul","","",1,[[["self"],["usize"]],["bigint"]]],[11,"mul","","",1,[[["self"],["usize"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i8"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i8"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i16"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i16"]],["bigint"]]],[11,"mul","","",1,[[["self"],["isize"]],["bigint"]]],[11,"mul","","",1,[[["self"],["isize"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u32"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u64"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u128"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u32"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u64"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u128"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i32"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i64"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i128"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i32"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i64"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i128"]],["bigint"]]],[11,"mul","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"mul","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u8"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u8"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u16"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u16"]],["biguint"]]],[11,"mul","","",2,[[["self"],["usize"]],["biguint"]]],[11,"mul","","",2,[[["self"],["usize"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u32"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u64"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u128"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u32"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u64"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u128"]],["biguint"]]],[11,"div","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"div","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"div","","",1,[[["self"],["u8"]],["bigint"]]],[11,"div","","",1,[[["self"],["u8"]],["bigint"]]],[11,"div","","",1,[[["self"],["u16"]],["bigint"]]],[11,"div","","",1,[[["self"],["u16"]],["bigint"]]],[11,"div","","",1,[[["self"],["usize"]],["bigint"]]],[11,"div","","",1,[[["self"],["usize"]],["bigint"]]],[11,"div","","",1,[[["self"],["i8"]],["bigint"]]],[11,"div","","",1,[[["self"],["i8"]],["bigint"]]],[11,"div","","",1,[[["self"],["i16"]],["bigint"]]],[11,"div","","",1,[[["self"],["i16"]],["bigint"]]],[11,"div","","",1,[[["self"],["isize"]],["bigint"]]],[11,"div","","",1,[[["self"],["isize"]],["bigint"]]],[11,"div","","",1,[[["self"],["u32"]],["bigint"]]],[11,"div","","",1,[[["self"],["u64"]],["bigint"]]],[11,"div","","",1,[[["self"],["u128"]],["bigint"]]],[11,"div","","",1,[[["self"],["u32"]],["bigint"]]],[11,"div","","",1,[[["self"],["u64"]],["bigint"]]],[11,"div","","",1,[[["self"],["u128"]],["bigint"]]],[11,"div","","",1,[[["self"],["i32"]],["bigint"]]],[11,"div","","",1,[[["self"],["i64"]],["bigint"]]],[11,"div","","",1,[[["self"],["i128"]],["bigint"]]],[11,"div","","",1,[[["self"],["i32"]],["bigint"]]],[11,"div","","",1,[[["self"],["i64"]],["bigint"]]],[11,"div","","",1,[[["self"],["i128"]],["bigint"]]],[11,"div","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"div","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"div","","",2,[[["self"],["u8"]],["biguint"]]],[11,"div","","",2,[[["self"],["u8"]],["biguint"]]],[11,"div","","",2,[[["self"],["u16"]],["biguint"]]],[11,"div","","",2,[[["self"],["u16"]],["biguint"]]],[11,"div","","",2,[[["self"],["usize"]],["biguint"]]],[11,"div","","",2,[[["self"],["usize"]],["biguint"]]],[11,"div","","",2,[[["self"],["u32"]],["biguint"]]],[11,"div","","",2,[[["self"],["u64"]],["biguint"]]],[11,"div","","",2,[[["self"],["u128"]],["biguint"]]],[11,"div","","",2,[[["self"],["u32"]],["biguint"]]],[11,"div","","",2,[[["self"],["u64"]],["biguint"]]],[11,"div","","",2,[[["self"],["u128"]],["biguint"]]],[11,"rem","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"rem","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u8"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u8"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u16"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u16"]],["bigint"]]],[11,"rem","","",1,[[["self"],["usize"]],["bigint"]]],[11,"rem","","",1,[[["self"],["usize"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i8"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i8"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i16"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i16"]],["bigint"]]],[11,"rem","","",1,[[["self"],["isize"]],["bigint"]]],[11,"rem","","",1,[[["self"],["isize"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u32"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u64"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u128"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u32"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u64"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u128"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i32"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i64"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i128"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i32"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i64"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i128"]],["bigint"]]],[11,"rem","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"rem","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u8"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u8"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u16"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u16"]],["biguint"]]],[11,"rem","","",2,[[["self"],["usize"]],["biguint"]]],[11,"rem","","",2,[[["self"],["usize"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u32"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u64"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u128"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u32"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u64"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u128"]],["biguint"]]],[11,"neg","","Negate Sign value.",0,[[["self"]],["sign"]]],[11,"neg","","",1,[[["self"]],["bigint"]]],[11,"neg","","",2,[[["self"]],["biguint"]]],[11,"add_assign","","",1,[[["self"],["bigint"]]]],[11,"add_assign","","",1,[[["self"],["bigint"]]]],[11,"add_assign","","",1,[[["self"],["u8"]]]],[11,"add_assign","","",1,[[["self"],["u16"]]]],[11,"add_assign","","",1,[[["self"],["usize"]]]],[11,"add_assign","","",1,[[["self"],["i8"]]]],[11,"add_assign","","",1,[[["self"],["i16"]]]],[11,"add_assign","","",1,[[["self"],["isize"]]]],[11,"add_assign","","",1,[[["self"],["u32"]]]],[11,"add_assign","","",1,[[["self"],["u64"]]]],[11,"add_assign","","",1,[[["self"],["u128"]]]],[11,"add_assign","","",1,[[["self"],["i32"]]]],[11,"add_assign","","",1,[[["self"],["i64"]]]],[11,"add_assign","","",1,[[["self"],["i128"]]]],[11,"add_assign","","",2,[[["self"],["biguint"]]]],[11,"add_assign","","",2,[[["self"],["biguint"]]]],[11,"add_assign","","",2,[[["self"],["u8"]]]],[11,"add_assign","","",2,[[["self"],["u16"]]]],[11,"add_assign","","",2,[[["self"],["usize"]]]],[11,"add_assign","","",2,[[["self"],["u32"]]]],[11,"add_assign","","",2,[[["self"],["u64"]]]],[11,"add_assign","","",2,[[["self"],["u128"]]]],[11,"sub_assign","","",1,[[["self"],["bigint"]]]],[11,"sub_assign","","",1,[[["self"],["bigint"]]]],[11,"sub_assign","","",1,[[["self"],["u8"]]]],[11,"sub_assign","","",1,[[["self"],["u16"]]]],[11,"sub_assign","","",1,[[["self"],["usize"]]]],[11,"sub_assign","","",1,[[["self"],["i8"]]]],[11,"sub_assign","","",1,[[["self"],["i16"]]]],[11,"sub_assign","","",1,[[["self"],["isize"]]]],[11,"sub_assign","","",1,[[["self"],["u32"]]]],[11,"sub_assign","","",1,[[["self"],["u64"]]]],[11,"sub_assign","","",1,[[["self"],["u128"]]]],[11,"sub_assign","","",1,[[["self"],["i32"]]]],[11,"sub_assign","","",1,[[["self"],["i64"]]]],[11,"sub_assign","","",1,[[["self"],["i128"]]]],[11,"sub_assign","","",2,[[["self"],["biguint"]]]],[11,"sub_assign","","",2,[[["self"],["biguint"]]]],[11,"sub_assign","","",2,[[["self"],["u8"]]]],[11,"sub_assign","","",2,[[["self"],["u16"]]]],[11,"sub_assign","","",2,[[["self"],["usize"]]]],[11,"sub_assign","","",2,[[["self"],["u32"]]]],[11,"sub_assign","","",2,[[["self"],["u64"]]]],[11,"sub_assign","","",2,[[["self"],["u128"]]]],[11,"mul_assign","","",1,[[["self"],["bigint"]]]],[11,"mul_assign","","",1,[[["self"],["bigint"]]]],[11,"mul_assign","","",1,[[["self"],["u8"]]]],[11,"mul_assign","","",1,[[["self"],["u16"]]]],[11,"mul_assign","","",1,[[["self"],["usize"]]]],[11,"mul_assign","","",1,[[["self"],["i8"]]]],[11,"mul_assign","","",1,[[["self"],["i16"]]]],[11,"mul_assign","","",1,[[["self"],["isize"]]]],[11,"mul_assign","","",1,[[["self"],["u32"]]]],[11,"mul_assign","","",1,[[["self"],["u64"]]]],[11,"mul_assign","","",1,[[["self"],["u128"]]]],[11,"mul_assign","","",1,[[["self"],["i32"]]]],[11,"mul_assign","","",1,[[["self"],["i64"]]]],[11,"mul_assign","","",1,[[["self"],["i128"]]]],[11,"mul_assign","","",2,[[["self"],["biguint"]]]],[11,"mul_assign","","",2,[[["self"],["biguint"]]]],[11,"mul_assign","","",2,[[["self"],["u8"]]]],[11,"mul_assign","","",2,[[["self"],["u16"]]]],[11,"mul_assign","","",2,[[["self"],["usize"]]]],[11,"mul_assign","","",2,[[["self"],["u32"]]]],[11,"mul_assign","","",2,[[["self"],["u64"]]]],[11,"mul_assign","","",2,[[["self"],["u128"]]]],[11,"div_assign","","",1,[[["self"],["bigint"]]]],[11,"div_assign","","",1,[[["self"],["bigint"]]]],[11,"div_assign","","",1,[[["self"],["u8"]]]],[11,"div_assign","","",1,[[["self"],["u16"]]]],[11,"div_assign","","",1,[[["self"],["usize"]]]],[11,"div_assign","","",1,[[["self"],["i8"]]]],[11,"div_assign","","",1,[[["self"],["i16"]]]],[11,"div_assign","","",1,[[["self"],["isize"]]]],[11,"div_assign","","",1,[[["self"],["u32"]]]],[11,"div_assign","","",1,[[["self"],["u64"]]]],[11,"div_assign","","",1,[[["self"],["u128"]]]],[11,"div_assign","","",1,[[["self"],["i32"]]]],[11,"div_assign","","",1,[[["self"],["i64"]]]],[11,"div_assign","","",1,[[["self"],["i128"]]]],[11,"div_assign","","",2,[[["self"],["biguint"]]]],[11,"div_assign","","",2,[[["self"],["biguint"]]]],[11,"div_assign","","",2,[[["self"],["u8"]]]],[11,"div_assign","","",2,[[["self"],["u16"]]]],[11,"div_assign","","",2,[[["self"],["usize"]]]],[11,"div_assign","","",2,[[["self"],["u32"]]]],[11,"div_assign","","",2,[[["self"],["u64"]]]],[11,"div_assign","","",2,[[["self"],["u128"]]]],[11,"rem_assign","","",1,[[["self"],["bigint"]]]],[11,"rem_assign","","",1,[[["self"],["bigint"]]]],[11,"rem_assign","","",1,[[["self"],["u8"]]]],[11,"rem_assign","","",1,[[["self"],["u16"]]]],[11,"rem_assign","","",1,[[["self"],["usize"]]]],[11,"rem_assign","","",1,[[["self"],["i8"]]]],[11,"rem_assign","","",1,[[["self"],["i16"]]]],[11,"rem_assign","","",1,[[["self"],["isize"]]]],[11,"rem_assign","","",1,[[["self"],["u32"]]]],[11,"rem_assign","","",1,[[["self"],["u64"]]]],[11,"rem_assign","","",1,[[["self"],["u128"]]]],[11,"rem_assign","","",1,[[["self"],["i32"]]]],[11,"rem_assign","","",1,[[["self"],["i64"]]]],[11,"rem_assign","","",1,[[["self"],["i128"]]]],[11,"rem_assign","","",2,[[["self"],["biguint"]]]],[11,"rem_assign","","",2,[[["self"],["biguint"]]]],[11,"rem_assign","","",2,[[["self"],["u8"]]]],[11,"rem_assign","","",2,[[["self"],["u16"]]]],[11,"rem_assign","","",2,[[["self"],["usize"]]]],[11,"rem_assign","","",2,[[["self"],["u32"]]]],[11,"rem_assign","","",2,[[["self"],["u64"]]]],[11,"rem_assign","","",2,[[["self"],["u128"]]]],[11,"not","","",1,[[["self"]],["bigint"]]],[11,"bitand","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitand","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitand","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"bitand","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"bitor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"bitor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"bitxor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitxor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitxor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"bitxor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"shl","","",1,[[["self"],["usize"]],["bigint"]]],[11,"shl","","",2,[[["self"],["usize"]],["biguint"]]],[11,"shr","","",1,[[["self"],["usize"]],["bigint"]]],[11,"shr","","",2,[[["self"],["usize"]],["biguint"]]],[11,"bitand_assign","","",1,[[["self"],["bigint"]]]],[11,"bitand_assign","","",1,[[["self"],["bigint"]]]],[11,"bitand_assign","","",2,[[["self"],["biguint"]]]],[11,"bitand_assign","","",2,[[["self"],["biguint"]]]],[11,"bitor_assign","","",1,[[["self"],["bigint"]]]],[11,"bitor_assign","","",1,[[["self"],["bigint"]]]],[11,"bitor_assign","","",2,[[["self"],["biguint"]]]],[11,"bitor_assign","","",2,[[["self"],["biguint"]]]],[11,"bitxor_assign","","",1,[[["self"],["bigint"]]]],[11,"bitxor_assign","","",1,[[["self"],["bigint"]]]],[11,"bitxor_assign","","",2,[[["self"],["biguint"]]]],[11,"bitxor_assign","","",2,[[["self"],["biguint"]]]],[11,"shl_assign","","",1,[[["self"],["usize"]]]],[11,"shl_assign","","",2,[[["self"],["usize"]]]],[11,"shr_assign","","",1,[[["self"],["usize"]]]],[11,"shr_assign","","",2,[[["self"],["usize"]]]],[11,"product","","",1,[[["i"]],["self"]]],[11,"product","","",2,[[["i"]],["self"]]],[11,"sum","","",1,[[["i"]],["self"]]],[11,"sum","","",2,[[["i"]],["self"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"description","","",5,[[["self"]],["str"]]],[11,"nth_root","","",1,[[["self"],["u32"]],["self"]]],[11,"sqrt","","",1,[[["self"]],["self"]]],[11,"cbrt","","",1,[[["self"]],["self"]]],[11,"nth_root","","",2,[[["self"],["u32"]],["self"]]],[11,"sqrt","","",2,[[["self"]],["self"]]],[11,"cbrt","","",2,[[["self"]],["self"]]],[11,"div_rem","","",1,N],[11,"div_floor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"mod_floor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"div_mod_floor","","",1,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",1,[[["self"],["bigint"]],["bigint"]]],[11,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",1,[[["self"],["bigint"]],["bigint"]]],[11,"divides","","Deprecated, use `is_multiple_of` instead.",1,[[["self"],["bigint"]],["bool"]]],[11,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",1,[[["self"],["bigint"]],["bool"]]],[11,"is_even","","Returns `true` if the number is divisible by `2`.",1,[[["self"]],["bool"]]],[11,"is_odd","","Returns `true` if the number is not divisible by `2`.",1,[[["self"]],["bool"]]],[11,"div_rem","","",2,N],[11,"div_floor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"mod_floor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"div_mod_floor","","",2,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",2,[[["self"],["self"]],["self"]]],[11,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",2,[[["self"],["biguint"]],["biguint"]]],[11,"divides","","Deprecated, use `is_multiple_of` instead.",2,[[["self"],["biguint"]],["bool"]]],[11,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",2,[[["self"],["biguint"]],["bool"]]],[11,"is_even","","Returns `true` if the number is divisible by `2`.",2,[[["self"]],["bool"]]],[11,"is_odd","","Returns `true` if the number is not divisible by `2`.",2,[[["self"]],["bool"]]],[11,"to_i64","","",1,[[["self"]],["option",["i64"]]]],[11,"to_i128","","",1,[[["self"]],["option",["i128"]]]],[11,"to_u64","","",1,[[["self"]],["option",["u64"]]]],[11,"to_u128","","",1,[[["self"]],["option",["u128"]]]],[11,"to_f32","","",1,[[["self"]],["option",["f32"]]]],[11,"to_f64","","",1,[[["self"]],["option",["f64"]]]],[11,"to_i64","","",2,[[["self"]],["option",["i64"]]]],[11,"to_i128","","",2,[[["self"]],["option",["i128"]]]],[11,"to_u64","","",2,[[["self"]],["option",["u64"]]]],[11,"to_u128","","",2,[[["self"]],["option",["u128"]]]],[11,"to_f32","","",2,[[["self"]],["option",["f32"]]]],[11,"to_f64","","",2,[[["self"]],["option",["f64"]]]],[11,"from_i64","","",1,[[["i64"]],["option",["bigint"]]]],[11,"from_i128","","",1,[[["i128"]],["option",["bigint"]]]],[11,"from_u64","","",1,[[["u64"]],["option",["bigint"]]]],[11,"from_u128","","",1,[[["u128"]],["option",["bigint"]]]],[11,"from_f64","","",1,[[["f64"]],["option",["bigint"]]]],[11,"from_i64","","",2,[[["i64"]],["option",["biguint"]]]],[11,"from_i128","","",2,[[["i128"]],["option",["biguint"]]]],[11,"from_u64","","",2,[[["u64"]],["option",["biguint"]]]],[11,"from_u128","","",2,[[["u128"]],["option",["biguint"]]]],[11,"from_f64","","",2,[[["f64"]],["option",["biguint"]]]],[11,"from_str_radix","","Creates and initializes a BigInt.",1,[[["str"],["u32"]],["result",["bigint","parsebiginterror"]]]],[11,"from_str_radix","","Creates and initializes a `BigUint`.",2,[[["str"],["u32"]],["result",["biguint","parsebiginterror"]]]],[11,"zero","","",1,[[],["bigint"]]],[11,"is_zero","","",1,[[["self"]],["bool"]]],[11,"zero","","",2,[[],["biguint"]]],[11,"is_zero","","",2,[[["self"]],["bool"]]],[11,"one","","",1,[[],["bigint"]]],[11,"is_one","","",1,[[["self"]],["bool"]]],[11,"one","","",2,[[],["biguint"]]],[11,"is_one","","",2,[[["self"]],["bool"]]],[11,"checked_div","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_div","","",2,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"checked_sub","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_sub","","",2,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"checked_mul","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_mul","","",2,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"checked_add","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_add","","",2,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"abs","","",1,[[["self"]],["bigint"]]],[11,"abs_sub","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"signum","","",1,[[["self"]],["bigint"]]],[11,"is_positive","","",1,[[["self"]],["bool"]]],[11,"is_negative","","",1,[[["self"]],["bool"]]]],"paths":[[4,"Sign"],[3,"BigInt"],[3,"BigUint"],[8,"ToBigUint"],[8,"ToBigInt"],[3,"ParseBigIntError"]]};
searchIndex["num_integer"]={"doc":"Integer trait and functions.","items":[[3,"IterBinomial","num_integer","An iterator over binomial coefficients.",N,N],[5,"sqrt","","Returns the truncated principal square root of an integer -- see Roots::sqrt.",N,[[["t"]],["t"]]],[5,"cbrt","","Returns the truncated principal cube root of an integer -- see Roots::cbrt.",N,[[["t"]],["t"]]],[5,"nth_root","","Returns the truncated principal `n`th root of an integer -- see Roots::nth_root.",N,[[["t"],["u32"]],["t"]]],[5,"div_rem","","Simultaneous integer division and modulus",N,N],[5,"div_floor","","Floored integer division",N,[[["t"],["t"]],["t"]]],[5,"mod_floor","","Floored integer modulus",N,[[["t"],["t"]],["t"]]],[5,"div_mod_floor","","Simultaneous floored integer division and modulus",N,N],[5,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`. The result is always positive.",N,[[["t"],["t"]],["t"]]],[5,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",N,[[["t"],["t"]],["t"]]],[5,"binomial","","Calculate the binomial coefficient.",N,[[["t"],["t"]],["t"]]],[5,"multinomial","","Calculate the multinomial coefficient.",N,N],[8,"Roots","","Provides methods to compute an integer's square root, cube root, and arbitrary `n`th root.",N,N],[10,"nth_root","","Returns the truncated principal `n`th root of an integer -- `if x >= 0 { x } else { x }`",0,[[["self"],["u32"]],["self"]]],[11,"sqrt","","Returns the truncated principal square root of an integer -- `x`",0,[[["self"]],["self"]]],[11,"cbrt","","Returns the truncated principal cube root of an integer -- `if x >= 0 { x } else { x }`",0,[[["self"]],["self"]]],[8,"Integer","","",N,N],[10,"div_floor","","Floored integer division.",1,[[["self"],["self"]],["self"]]],[10,"mod_floor","","Floored integer modulo, satisfying:",1,[[["self"],["self"]],["self"]]],[10,"gcd","","Greatest Common Divisor (GCD).",1,[[["self"],["self"]],["self"]]],[10,"lcm","","Lowest Common Multiple (LCM).",1,[[["self"],["self"]],["self"]]],[10,"divides","","Deprecated, use `is_multiple_of` instead.",1,[[["self"],["self"]],["bool"]]],[10,"is_multiple_of","","Returns `true` if `self` is a multiple of `other`.",1,[[["self"],["self"]],["bool"]]],[10,"is_even","","Returns `true` if the number is even.",1,[[["self"]],["bool"]]],[10,"is_odd","","Returns `true` if the number is odd.",1,[[["self"]],["bool"]]],[10,"div_rem","","Simultaneous truncated integer division and modulus. Returns `(quotient, remainder)`.",1,N],[11,"div_mod_floor","","Simultaneous floored integer division and modulus. Returns `(quotient, remainder)`.",1,N],[11,"new","","For a given n, iterate over all binomial coefficients binomial(n, k), for k=0...n.",2,[[["t"]],["iterbinomial"]]],[11,"into_iter","","",2,[[["self"]],["i"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"next","","",2,[[["self"]],["option"]]],[11,"sqrt","","Returns the truncated principal square root of an integer -- `x`",0,[[["self"]],["self"]]],[11,"cbrt","","Returns the truncated principal cube root of an integer -- `if x >= 0 { x } else { x }`",0,[[["self"]],["self"]]]],"paths":[[8,"Roots"],[8,"Integer"],[3,"IterBinomial"]]};
searchIndex["num_traits"]={"doc":"Numeric traits for generic mathematics","items":[[3,"ParseFloatError","num_traits","",N,N],[12,"kind","","",0,N],[4,"FloatErrorKind","","",N,N],[13,"Empty","","",1,N],[13,"Invalid","","",1,N],[5,"clamp","","A value bounded by a minimum and a maximum",N,[[["t"],["t"],["t"]],["t"]]],[0,"bounds","","",N,N],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",N,N],[10,"min_value","","returns the smallest finite number this type can represent",2,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",2,[[],["self"]]],[0,"cast","num_traits","",N,N],[5,"cast","num_traits::cast","Cast from one machine scalar to another.",N,[[["t"]],["option"]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",N,N],[11,"to_isize","","Converts the value of `self` to an `isize`.",3,[[["self"]],["option",["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`.",3,[[["self"]],["option",["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`.",3,[[["self"]],["option",["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`.",3,[[["self"]],["option",["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`.",3,[[["self"]],["option",["i64"]]]],[11,"to_i128","","Converts the value of `self` to an `i128`.",3,[[["self"]],["option",["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`.",3,[[["self"]],["option",["usize"]]]],[11,"to_u8","","Converts the value of `self` to an `u8`.",3,[[["self"]],["option",["u8"]]]],[11,"to_u16","","Converts the value of `self` to an `u16`.",3,[[["self"]],["option",["u16"]]]],[11,"to_u32","","Converts the value of `self` to an `u32`.",3,[[["self"]],["option",["u32"]]]],[10,"to_u64","","Converts the value of `self` to an `u64`.",3,[[["self"]],["option",["u64"]]]],[11,"to_u128","","Converts the value of `self` to an `u128`.",3,[[["self"]],["option",["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`.",3,[[["self"]],["option",["f32"]]]],[11,"to_f64","","Converts the value of `self` to an `f64`.",3,[[["self"]],["option",["f64"]]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",N,N],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the value cannot be represented by this value, then `None` is returned.",4,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["f64"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",N,N],[10,"from","","Creates a number from another value that can be converted into a primitive via the `ToPrimitive` trait.",5,[[["t"]],["option"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars with the `as` operator, which admits narrowing and precision loss. Implementers of this trait AsPrimitive should behave like a primitive numeric type (e.g. a newtype around another primitive), and the intended conversion must never fail.",N,N],[10,"as_","","Convert a value to another, using the `as` operator.",6,[[["self"]],["t"]]],[0,"float","num_traits","",N,N],[8,"FloatCore","num_traits::float","Generic trait for floating point numbers that works with `no_std`.",N,N],[10,"infinity","","Returns positive infinity.",7,[[],["self"]]],[10,"neg_infinity","","Returns negative infinity.",7,[[],["self"]]],[10,"nan","","Returns NaN.",7,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",7,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can represent.",7,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",7,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",7,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",7,[[],["self"]]],[11,"is_nan","","Returns `true` if the number is NaN.",7,[[["self"]],["bool"]]],[11,"is_infinite","","Returns `true` if the number is infinite.",7,[[["self"]],["bool"]]],[11,"is_finite","","Returns `true` if the number is neither infinite or NaN.",7,[[["self"]],["bool"]]],[11,"is_normal","","Returns `true` if the number is neither zero, infinite, subnormal or NaN.",7,[[["self"]],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",7,[[["self"]],["fpcategory"]]],[11,"floor","","Returns the largest integer less than or equal to a number.",7,[[["self"]],["self"]]],[11,"ceil","","Returns the smallest integer greater than or equal to a number.",7,[[["self"]],["self"]]],[11,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",7,[[["self"]],["self"]]],[11,"trunc","","Return the integer part of a number.",7,[[["self"]],["self"]]],[11,"fract","","Returns the fractional part of a number.",7,[[["self"]],["self"]]],[11,"abs","","Computes the absolute value of `self`. Returns `FloatCore::nan()` if the number is `FloatCore::nan()`.",7,[[["self"]],["self"]]],[11,"signum","","Returns a number that represents the sign of `self`.",7,[[["self"]],["self"]]],[11,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and `FloatCore::infinity()`, and since Rust 1.20 also `FloatCore::nan()`.",7,[[["self"]],["bool"]]],[11,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and `FloatCore::neg_infinity()`, and since Rust 1.20 also `-FloatCore::nan()`.",7,[[["self"]],["bool"]]],[11,"min","","Returns the minimum of the two numbers.",7,[[["self"],["self"]],["self"]]],[11,"max","","Returns the maximum of the two numbers.",7,[[["self"],["self"]],["self"]]],[11,"recip","","Returns the reciprocal (multiplicative inverse) of the number.",7,[[["self"]],["self"]]],[11,"powi","","Raise a number to an integer power.",7,[[["self"],["i32"]],["self"]]],[10,"to_degrees","","Converts to degrees, assuming the number is in radians.",7,[[["self"]],["self"]]],[10,"to_radians","","Converts to radians, assuming the number is in degrees.",7,[[["self"]],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",7,N],[8,"Float","","Generic trait for floating point numbers",N,N],[10,"nan","","Returns the `NaN` value.",8,[[],["self"]]],[10,"infinity","","Returns the infinite value.",8,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",8,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",8,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can represent.",8,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",8,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",8,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",8,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",8,[[["self"]],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and false otherwise.",8,[[["self"]],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",8,[[["self"]],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite, [subnormal][subnormal], or `NaN`.",8,[[["self"]],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",8,[[["self"]],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",8,[[["self"]],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",8,[[["self"]],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",8,[[["self"]],["self"]]],[10,"trunc","","Return the integer part of a number.",8,[[["self"]],["self"]]],[10,"fract","","Returns the fractional part of a number.",8,[[["self"]],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",8,[[["self"]],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",8,[[["self"]],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and since Rust 1.20 also `Float::nan()`.",8,[[["self"]],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and since Rust 1.20 also `-Float::nan()`.",8,[[["self"]],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",8,[[["self"],["self"],["self"]],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",8,[[["self"]],["self"]]],[10,"powi","","Raise a number to an integer power.",8,[[["self"],["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",8,[[["self"],["self"]],["self"]]],[10,"sqrt","","Take the square root of a number.",8,[[["self"]],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",8,[[["self"]],["self"]]],[10,"exp2","","Returns `2^(self)`.",8,[[["self"]],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",8,[[["self"]],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",8,[[["self"],["self"]],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",8,[[["self"]],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",8,[[["self"]],["self"]]],[11,"to_degrees","","Converts radians to degrees.",8,[[["self"]],["self"]]],[11,"to_radians","","Converts degrees to radians.",8,[[["self"]],["self"]]],[10,"max","","Returns the maximum of the two numbers.",8,[[["self"],["self"]],["self"]]],[10,"min","","Returns the minimum of the two numbers.",8,[[["self"],["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",8,[[["self"],["self"]],["self"]]],[10,"cbrt","","Take the cubic root of a number.",8,[[["self"]],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",8,[[["self"],["self"]],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",8,[[["self"]],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",8,[[["self"]],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",8,[[["self"]],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",8,[[["self"]],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",8,[[["self"]],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",8,[[["self"]],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",8,[[["self"],["self"]],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",8,N],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",8,[[["self"]],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",8,[[["self"]],["self"]]],[10,"sinh","","Hyperbolic sine function.",8,[[["self"]],["self"]]],[10,"cosh","","Hyperbolic cosine function.",8,[[["self"]],["self"]]],[10,"tanh","","Hyperbolic tangent function.",8,[[["self"]],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",8,[[["self"]],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",8,[[["self"]],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",8,[[["self"]],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",8,N],[8,"FloatConst","","",N,N],[10,"E","","Return Eulers number.",9,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / `.",9,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",9,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / `.",9,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt()`.",9,[[],["self"]]],[10,"FRAC_PI_2","","Return ` / 2.0`.",9,[[],["self"]]],[10,"FRAC_PI_3","","Return ` / 3.0`.",9,[[],["self"]]],[10,"FRAC_PI_4","","Return ` / 4.0`.",9,[[],["self"]]],[10,"FRAC_PI_6","","Return ` / 6.0`.",9,[[],["self"]]],[10,"FRAC_PI_8","","Return ` / 8.0`.",9,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",9,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",9,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",9,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",9,[[],["self"]]],[10,"PI","","Return Archimedes constant.",9,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",9,[[],["self"]]],[0,"identities","num_traits","",N,N],[5,"zero","num_traits::identities","Returns the additive identity, `0`.",N,[[],["t"]]],[5,"one","","Returns the multiplicative identity, `1`.",N,[[],["t"]]],[8,"Zero","","Defines an additive identity element for `Self`.",N,N],[10,"zero","","Returns the additive identity element of `Self`, `0`.",10,[[],["self"]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",10,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",N,N],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",11,[[],["self"]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative identity.",11,[[["self"]],["bool"]]],[0,"int","num_traits","",N,N],[8,"PrimInt","num_traits::int","",N,N],[10,"count_ones","","Returns the number of ones in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping the truncated bits to the end of the resulting integer.",12,[[["self"],["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping the truncated bits to the beginning of the resulting integer.",12,[[["self"],["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount, `n`, copying the \"sign bit\" in the most significant bits even for unsigned types.",12,[[["self"],["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount, `n`, filling zeros in the most significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",12,[[["self"]],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's endianness.",12,[[["self"]],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's endianness.",12,[[["self"]],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",12,[[["self"]],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's endianness.",12,[[["self"]],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by squaring.",12,[[["self"],["u32"]],["self"]]],[0,"ops","num_traits","",N,N],[0,"checked","num_traits::ops","",N,N],[8,"CheckedAdd","num_traits::ops::checked","Performs addition that returns `None` instead of wrapping around on overflow.",N,N],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is returned.",13,[[["self"],["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow.",N,N],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.",14,[[["self"],["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or overflow.",N,N],[10,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, `None` is returned.",15,[[["self"],["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.",N,N],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and division by zero. If any of that happens, `None` is returned.",16,[[["self"],["self"]],["option"]]],[8,"CheckedRem","","Performs an integral remainder that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.",N,N],[10,"checked_rem","","Finds the remainder of dividing two numbers, checking for underflow, overflow and division by zero. If any of that happens, `None` is returned.",17,[[["self"],["self"]],["option"]]],[8,"CheckedNeg","","Performs negation that returns `None` if the result can't be represented.",N,N],[10,"checked_neg","","Negates a number, returning `None` for results that can't be represented, like signed `MIN` values that can't be positive, or non-zero unsigned values that can't be negative.",18,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on overflow.",N,N],[10,"checked_shl","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",19,[[["self"],["u32"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on overflow.",N,N],[10,"checked_shr","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",20,[[["self"],["u32"]],["option"]]],[0,"inv","num_traits::ops","",N,N],[8,"Inv","num_traits::ops::inv","Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value.",N,N],[16,"Output","","The result after applying the operator.",21,N],[10,"inv","","Returns the multiplicative inverse of `self`.",21,N],[0,"mul_add","num_traits::ops","",N,N],[8,"MulAdd","num_traits::ops::mul_add","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",N,N],[16,"Output","","The resulting type after applying the fused multiply-add.",22,N],[10,"mul_add","","Performs the fused multiply-add operation.",22,N],[8,"MulAddAssign","","The fused multiply-add assignment operation.",N,N],[10,"mul_add_assign","","Performs the fused multiply-add operation.",23,[[["self"],["a"],["b"]]]],[0,"saturating","num_traits::ops","",N,N],[8,"Saturating","num_traits::ops::saturating","Saturating math operations",N,N],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at the numeric bounds instead of overflowing.",24,[[["self"],["self"]],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating at the numeric bounds instead of overflowing.",24,[[["self"],["self"]],["self"]]],[0,"wrapping","num_traits::ops","",N,N],[8,"WrappingAdd","num_traits::ops::wrapping","Performs addition that wraps around on overflow.",N,N],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of the type.",25,[[["self"],["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",N,N],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary of the type.",26,[[["self"],["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",N,N],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary of the type.",27,[[["self"],["self"]],["self"]]],[8,"WrappingShl","","Performs a left shift that does not panic.",N,N],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes any high order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.",28,[[["self"],["u32"]],["self"]]],[8,"WrappingShr","","Performs a right shift that does not panic.",N,N],[10,"wrapping_shr","","Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask` removes any high order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.",29,[[["self"],["u32"]],["self"]]],[0,"pow","num_traits","",N,N],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation by squaring.",N,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an overflow occurred.",N,[[["t"],["usize"]],["option"]]],[8,"Pow","","Binary operator for raising a value to a power.",N,N],[16,"Output","","The result after applying the operator.",30,N],[10,"pow","","Returns `self` to the power `rhs`.",30,N],[0,"real","num_traits","",N,N],[8,"Real","num_traits::real","A trait for real number types that do not necessarily have floating-point-specific characteristics such as NaN and infinity.",N,N],[10,"min_value","","Returns the smallest finite value that this type can represent.",31,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",31,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",31,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",31,[[],["self"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",31,[[["self"]],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",31,[[["self"]],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",31,[[["self"]],["self"]]],[10,"trunc","","Return the integer part of a number.",31,[[["self"]],["self"]]],[10,"fract","","Returns the fractional part of a number.",31,[[["self"]],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",31,[[["self"]],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",31,[[["self"]],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and with newer versions of Rust `f64::NAN`.",31,[[["self"]],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.",31,[[["self"]],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",31,[[["self"],["self"],["self"]],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",31,[[["self"]],["self"]]],[10,"powi","","Raise a number to an integer power.",31,[[["self"],["i32"]],["self"]]],[10,"powf","","Raise a number to a real number power.",31,[[["self"],["self"]],["self"]]],[10,"sqrt","","Take the square root of a number.",31,[[["self"]],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",31,[[["self"]],["self"]]],[10,"exp2","","Returns `2^(self)`.",31,[[["self"]],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",31,[[["self"]],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",31,[[["self"],["self"]],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",31,[[["self"]],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",31,[[["self"]],["self"]]],[10,"to_degrees","","Converts radians to degrees.",31,[[["self"]],["self"]]],[10,"to_radians","","Converts degrees to radians.",31,[[["self"]],["self"]]],[10,"max","","Returns the maximum of the two numbers.",31,[[["self"],["self"]],["self"]]],[10,"min","","Returns the minimum of the two numbers.",31,[[["self"],["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",31,[[["self"],["self"]],["self"]]],[10,"cbrt","","Take the cubic root of a number.",31,[[["self"]],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",31,[[["self"],["self"]],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",31,[[["self"]],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",31,[[["self"]],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",31,[[["self"]],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",31,[[["self"]],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",31,[[["self"]],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",31,[[["self"]],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",31,[[["self"],["self"]],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",31,N],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",31,[[["self"]],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",31,[[["self"]],["self"]]],[10,"sinh","","Hyperbolic sine function.",31,[[["self"]],["self"]]],[10,"cosh","","Hyperbolic cosine function.",31,[[["self"]],["self"]]],[10,"tanh","","Hyperbolic tangent function.",31,[[["self"]],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",31,[[["self"]],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",31,[[["self"]],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",31,[[["self"]],["self"]]],[0,"sign","num_traits","",N,N],[5,"abs","num_traits::sign","Computes the absolute value.",N,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",N,[[["t"],["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",N,[[["t"]],["t"]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative).",N,N],[10,"abs","","Computes the absolute value.",32,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",32,[[["self"],["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",32,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",32,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",32,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",N,N],[8,"Num","num_traits","The base trait for numeric types, covering `0` and `1` values, comparisons, basic numeric operations, and string conversion.",N,N],[16,"FromStrRadixErr","","",33,N],[10,"from_str_radix","","Convert from a string and radix <= 36.",33,[[["str"],["u32"]],["result"]]],[8,"NumOps","","The trait for types implementing basic numeric operations",N,N],[8,"NumRef","","The trait for `Num` types which also implement numeric operations taking the second operand by reference.",N,N],[8,"RefNum","","The trait for references which implement numeric operations, taking the second operand either by value or by reference.",N,N],[8,"NumAssignOps","","The trait for types implementing numeric assignment operators (like `+=`).",N,N],[8,"NumAssign","","The trait for `Num` types which also implement assignment operators.",N,N],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement assignment operations taking the second operand by reference.",N,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]]],"paths":[[3,"ParseFloatError"],[4,"FloatErrorKind"],[8,"Bounded"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"AsPrimitive"],[8,"FloatCore"],[8,"Float"],[8,"FloatConst"],[8,"Zero"],[8,"One"],[8,"PrimInt"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedRem"],[8,"CheckedNeg"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"Inv"],[8,"MulAdd"],[8,"MulAddAssign"],[8,"Saturating"],[8,"WrappingAdd"],[8,"WrappingSub"],[8,"WrappingMul"],[8,"WrappingShl"],[8,"WrappingShr"],[8,"Pow"],[8,"Real"],[8,"Signed"],[8,"Num"]]};
initSearch(searchIndex);
